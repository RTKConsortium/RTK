/*
  File autogenerated by gengetopt version 2.22.4
  generated with the following command:
  ../src/gengetopt --input=../../src/cmdline.ggo --output-dir=../../src --no-handle-version --no-handle-help --no-handle-error --string-parser

  The developers of gengetopt consider the fixed text that goes in all
  gengetopt output files to be in the public domain:
  we make no copyright claims on it.
*/

/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef FIX_UNUSED
#define FIX_UNUSED(X) (void) (X) /* avoid warnings for unused params */
#endif

#include <getopt.h>

#include "cmdline.h"

const char *gengetopt_args_info_purpose = "This program generates a C function that uses getopt_long function\nto parse the command line options, validate them and fill a struct.";

const char *gengetopt_args_info_usage = "Usage: " CMDLINE_PARSER_PACKAGE " [OPTIONS]...";

const char *gengetopt_args_info_description = "";

const char *gengetopt_args_info_detailed_help[] = {
  "  -h, --help                    Print help and exit",
  "      --detailed-help           Print help, including all details and hidden \n                                  options, and exit",
  "  -V, --version                 Print version and exit",
  "\nMain options:",
  "",
  "  -i, --input=filename          input file (default std input)",
  "  -f, --func-name=name          name of generated function  \n                                  (default=`cmdline_parser')",
  "  -a, --arg-struct-name=name    name of generated args info struct  \n                                  (default=`gengetopt_args_info')",
  "  -F, --file-name=name          name of generated file  (default=`cmdline')",
  "      --output-dir=path         output directory",
  "  \n  if this option is not specified, the files are generated in the current \n  directory.\n",
  "      --header-output-dir=path  header output directory",
  "      --src-output-dir=path     source output directory",
  "  -c, --c-extension=ext         extension of c file  (default=`c')",
  "  -H, --header-extension=ext    extension of header file  (default=`h')",
  "  -l, --long-help               long usage line in help",
  "  \n  The usage line will print all the options, e.g.,\n\n  sample1 -iINT|--int-opt=INT [-h|--help]\n",
  "      --default-optional        by default, an option is considered optional if \n                                  not specified otherwise",
  "  -u, --unamed-opts[=STRING]    accept options without names (e.g., file names) \n                                   (default=`FILES')",
  "\nThe parser generated is thought to be used to parse the command line arguments. \nHowever, you can also generate parsers for configuration files, or strings that \ncontain the arguments to parse, by using the following two options.\n",
  "  -C, --conf-parser             generate a config file parser",
  "  -S, --string-parser           generate a string parser (the string contains \n                                  the command line)",
  "",
  "\nAdditional options:",
  "  -G, --include-getopt          adds the code for getopt_long in the generated \n                                  C file",
  "  -n, --no-handle-help          do not handle --help|-h automatically",
  "  \n  If --no-handle-help is specified, the command line option --help|-h will not \n  be handled automatically, so the programmer will be able to print some other \n  information; then the function for printing the standard help output can be \n  used; this function is called <parser-name>_print_help.\n\n  Notice that, although the programmer can handle --help|-h manually, the \n  parser will return after finding such option: the other command line options, \n  if any, will be ignored.  In case you want to have full control on --help|-h, \n  you should use --ho-help.\n",
  "      --no-help                 do not add --help|-h automatically",
  "  \n  With this option you can disable the automatic addition of options --help|-h. \n  The programmer will then be able to add this option in the input file and \n  handle it as he sees fit.  Notice that --no-help will also disable the \n  automatic options --detailed-help and --full-help.\n\n  The programmer can still define options with short character h as he wants, \n  but he cannot define options help, unless he specifies --no-help (otherwise \n  an error will be printed).\n",
  "  -N, --no-handle-version       do not handle --version|-V automatically",
  "      --no-version              do not add --version|-V automatically",
  "  \n  See above the details about --no-handle-help and --no-help, respectively.\n",
  "  -e, --no-handle-error         do not exit on errors",
  "  \n  With this option, if the generated parser encounters an error (e.g., an \n  unknown option) it does not make the main program exit; instead, the parser \n  function returns a value different 0, and the main program can print a help \n  message.\n",
  "      --show-required[=STRING]  in the output of help will specify which \n                                  options are mandatory, by using the optional \n                                  passed string  (default=`(mandatory)')",
  "  -g, --gen-version             put gengetopt version in the generated file  \n                                  (default=on)",
  "      --set-package=STRING      set the package name (override package defined \n                                  in the .ggo file)",
  "      --set-version=STRING      set the version number (override version \n                                  defined in the .ggo file)",
  "      --show-help               show the output of --help instead of generating \n                                  code",
  "      --show-full-help          show the output of --full-help (i.e., including \n                                  hidden options) instead of generating code",
  "      --show-detailed-help      show the output of --detailed-help (i.e., \n                                  including details and hidden options) instead \n                                  of generating code",
  "      --show-version            show the output of --version instead of \n                                  generating code",
  "\nPlease refer to the info manual for further explanations.",
    0
};

static void
init_help_array(void)
{
  gengetopt_args_info_help[0] = gengetopt_args_info_detailed_help[0];
  gengetopt_args_info_help[1] = gengetopt_args_info_detailed_help[1];
  gengetopt_args_info_help[2] = gengetopt_args_info_detailed_help[2];
  gengetopt_args_info_help[3] = gengetopt_args_info_detailed_help[3];
  gengetopt_args_info_help[4] = gengetopt_args_info_detailed_help[4];
  gengetopt_args_info_help[5] = gengetopt_args_info_detailed_help[5];
  gengetopt_args_info_help[6] = gengetopt_args_info_detailed_help[6];
  gengetopt_args_info_help[7] = gengetopt_args_info_detailed_help[7];
  gengetopt_args_info_help[8] = gengetopt_args_info_detailed_help[8];
  gengetopt_args_info_help[9] = gengetopt_args_info_detailed_help[9];
  gengetopt_args_info_help[10] = gengetopt_args_info_detailed_help[11];
  gengetopt_args_info_help[11] = gengetopt_args_info_detailed_help[12];
  gengetopt_args_info_help[12] = gengetopt_args_info_detailed_help[13];
  gengetopt_args_info_help[13] = gengetopt_args_info_detailed_help[14];
  gengetopt_args_info_help[14] = gengetopt_args_info_detailed_help[15];
  gengetopt_args_info_help[15] = gengetopt_args_info_detailed_help[17];
  gengetopt_args_info_help[16] = gengetopt_args_info_detailed_help[18];
  gengetopt_args_info_help[17] = gengetopt_args_info_detailed_help[19];
  gengetopt_args_info_help[18] = gengetopt_args_info_detailed_help[20];
  gengetopt_args_info_help[19] = gengetopt_args_info_detailed_help[21];
  gengetopt_args_info_help[20] = gengetopt_args_info_detailed_help[22];
  gengetopt_args_info_help[21] = gengetopt_args_info_detailed_help[23];
  gengetopt_args_info_help[22] = gengetopt_args_info_detailed_help[24];
  gengetopt_args_info_help[23] = gengetopt_args_info_detailed_help[25];
  gengetopt_args_info_help[24] = gengetopt_args_info_detailed_help[27];
  gengetopt_args_info_help[25] = gengetopt_args_info_detailed_help[29];
  gengetopt_args_info_help[26] = gengetopt_args_info_detailed_help[30];
  gengetopt_args_info_help[27] = gengetopt_args_info_detailed_help[32];
  gengetopt_args_info_help[28] = gengetopt_args_info_detailed_help[34];
  gengetopt_args_info_help[29] = gengetopt_args_info_detailed_help[35];
  gengetopt_args_info_help[30] = gengetopt_args_info_detailed_help[36];
  gengetopt_args_info_help[31] = gengetopt_args_info_detailed_help[37];
  gengetopt_args_info_help[32] = gengetopt_args_info_detailed_help[38];
  gengetopt_args_info_help[33] = gengetopt_args_info_detailed_help[39];
  gengetopt_args_info_help[34] = gengetopt_args_info_detailed_help[40];
  gengetopt_args_info_help[35] = gengetopt_args_info_detailed_help[41];
  gengetopt_args_info_help[36] = gengetopt_args_info_detailed_help[42];
  gengetopt_args_info_help[37] = 0; 
  
}

const char *gengetopt_args_info_help[38];

typedef enum {ARG_NO
  , ARG_FLAG
  , ARG_STRING
} cmdline_parser_arg_type;

static
void clear_given (struct gengetopt_args_info *args_info);
static
void clear_args (struct gengetopt_args_info *args_info);

static int
cmdline_parser_internal (int argc, char **argv, struct gengetopt_args_info *args_info,
                        struct cmdline_parser_params *params, const char *additional_error);

struct line_list
{
  char * string_arg;
  struct line_list * next;
};

static struct line_list *cmd_line_list = 0;
static struct line_list *cmd_line_list_tmp = 0;

static void
free_cmd_list(void)
{
  /* free the list of a previous call */
  if (cmd_line_list)
    {
      while (cmd_line_list) {
        cmd_line_list_tmp = cmd_line_list;
        cmd_line_list = cmd_line_list->next;
        free (cmd_line_list_tmp->string_arg);
        free (cmd_line_list_tmp);
      }
    }
}


static char *
gengetopt_strdup (const char *s);

static
void clear_given (struct gengetopt_args_info *args_info)
{
  args_info->help_given = 0 ;
  args_info->detailed_help_given = 0 ;
  args_info->version_given = 0 ;
  args_info->input_given = 0 ;
  args_info->func_name_given = 0 ;
  args_info->arg_struct_name_given = 0 ;
  args_info->file_name_given = 0 ;
  args_info->output_dir_given = 0 ;
  args_info->header_output_dir_given = 0 ;
  args_info->src_output_dir_given = 0 ;
  args_info->c_extension_given = 0 ;
  args_info->header_extension_given = 0 ;
  args_info->long_help_given = 0 ;
  args_info->default_optional_given = 0 ;
  args_info->unamed_opts_given = 0 ;
  args_info->conf_parser_given = 0 ;
  args_info->string_parser_given = 0 ;
  args_info->include_getopt_given = 0 ;
  args_info->no_handle_help_given = 0 ;
  args_info->no_help_given = 0 ;
  args_info->no_handle_version_given = 0 ;
  args_info->no_version_given = 0 ;
  args_info->no_handle_error_given = 0 ;
  args_info->show_required_given = 0 ;
  args_info->gen_version_given = 0 ;
  args_info->set_package_given = 0 ;
  args_info->set_version_given = 0 ;
  args_info->show_help_given = 0 ;
  args_info->show_full_help_given = 0 ;
  args_info->show_detailed_help_given = 0 ;
  args_info->show_version_given = 0 ;
}

static
void clear_args (struct gengetopt_args_info *args_info)
{
  FIX_UNUSED (args_info);
  args_info->input_arg = NULL;
  args_info->input_orig = NULL;
  args_info->func_name_arg = gengetopt_strdup ("cmdline_parser");
  args_info->func_name_orig = NULL;
  args_info->arg_struct_name_arg = gengetopt_strdup ("gengetopt_args_info");
  args_info->arg_struct_name_orig = NULL;
  args_info->file_name_arg = gengetopt_strdup ("cmdline");
  args_info->file_name_orig = NULL;
  args_info->output_dir_arg = NULL;
  args_info->output_dir_orig = NULL;
  args_info->header_output_dir_arg = NULL;
  args_info->header_output_dir_orig = NULL;
  args_info->src_output_dir_arg = NULL;
  args_info->src_output_dir_orig = NULL;
  args_info->c_extension_arg = gengetopt_strdup ("c");
  args_info->c_extension_orig = NULL;
  args_info->header_extension_arg = gengetopt_strdup ("h");
  args_info->header_extension_orig = NULL;
  args_info->unamed_opts_arg = gengetopt_strdup ("FILES");
  args_info->unamed_opts_orig = NULL;
  args_info->show_required_arg = gengetopt_strdup ("(mandatory)");
  args_info->show_required_orig = NULL;
  args_info->gen_version_flag = 1;
  args_info->set_package_arg = NULL;
  args_info->set_package_orig = NULL;
  args_info->set_version_arg = NULL;
  args_info->set_version_orig = NULL;
  
}

static
void init_args_info(struct gengetopt_args_info *args_info)
{

  init_help_array(); 
  args_info->help_help = gengetopt_args_info_detailed_help[0] ;
  args_info->detailed_help_help = gengetopt_args_info_detailed_help[1] ;
  args_info->version_help = gengetopt_args_info_detailed_help[2] ;
  args_info->input_help = gengetopt_args_info_detailed_help[5] ;
  args_info->func_name_help = gengetopt_args_info_detailed_help[6] ;
  args_info->arg_struct_name_help = gengetopt_args_info_detailed_help[7] ;
  args_info->file_name_help = gengetopt_args_info_detailed_help[8] ;
  args_info->output_dir_help = gengetopt_args_info_detailed_help[9] ;
  args_info->header_output_dir_help = gengetopt_args_info_detailed_help[11] ;
  args_info->src_output_dir_help = gengetopt_args_info_detailed_help[12] ;
  args_info->c_extension_help = gengetopt_args_info_detailed_help[13] ;
  args_info->header_extension_help = gengetopt_args_info_detailed_help[14] ;
  args_info->long_help_help = gengetopt_args_info_detailed_help[15] ;
  args_info->default_optional_help = gengetopt_args_info_detailed_help[17] ;
  args_info->unamed_opts_help = gengetopt_args_info_detailed_help[18] ;
  args_info->conf_parser_help = gengetopt_args_info_detailed_help[20] ;
  args_info->string_parser_help = gengetopt_args_info_detailed_help[21] ;
  args_info->include_getopt_help = gengetopt_args_info_detailed_help[24] ;
  args_info->no_handle_help_help = gengetopt_args_info_detailed_help[25] ;
  args_info->no_help_help = gengetopt_args_info_detailed_help[27] ;
  args_info->no_handle_version_help = gengetopt_args_info_detailed_help[29] ;
  args_info->no_version_help = gengetopt_args_info_detailed_help[30] ;
  args_info->no_handle_error_help = gengetopt_args_info_detailed_help[32] ;
  args_info->show_required_help = gengetopt_args_info_detailed_help[34] ;
  args_info->gen_version_help = gengetopt_args_info_detailed_help[35] ;
  args_info->set_package_help = gengetopt_args_info_detailed_help[36] ;
  args_info->set_version_help = gengetopt_args_info_detailed_help[37] ;
  args_info->show_help_help = gengetopt_args_info_detailed_help[38] ;
  args_info->show_full_help_help = gengetopt_args_info_detailed_help[39] ;
  args_info->show_detailed_help_help = gengetopt_args_info_detailed_help[40] ;
  args_info->show_version_help = gengetopt_args_info_detailed_help[41] ;
  
}

void
cmdline_parser_print_version (void)
{
  printf ("%s %s\n",
     (strlen(CMDLINE_PARSER_PACKAGE_NAME) ? CMDLINE_PARSER_PACKAGE_NAME : CMDLINE_PARSER_PACKAGE),
     CMDLINE_PARSER_VERSION);
}

static void print_help_common(void) {
  cmdline_parser_print_version ();

  if (strlen(gengetopt_args_info_purpose) > 0)
    printf("\n%s\n", gengetopt_args_info_purpose);

  if (strlen(gengetopt_args_info_usage) > 0)
    printf("\n%s\n", gengetopt_args_info_usage);

  printf("\n");

  if (strlen(gengetopt_args_info_description) > 0)
    printf("%s\n\n", gengetopt_args_info_description);
}

void
cmdline_parser_print_help (void)
{
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_help[i])
    printf("%s\n", gengetopt_args_info_help[i++]);
}

void
cmdline_parser_print_detailed_help (void)
{
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_detailed_help[i])
    printf("%s\n", gengetopt_args_info_detailed_help[i++]);
}

void
cmdline_parser_init (struct gengetopt_args_info *args_info)
{
  clear_given (args_info);
  clear_args (args_info);
  init_args_info (args_info);
}

void
cmdline_parser_params_init(struct cmdline_parser_params *params)
{
  if (params)
    { 
      params->override = 0;
      params->initialize = 1;
      params->check_required = 1;
      params->check_ambiguity = 0;
      params->print_errors = 1;
    }
}

struct cmdline_parser_params *
cmdline_parser_params_create(void)
{
  struct cmdline_parser_params *params = 
    (struct cmdline_parser_params *)malloc(sizeof(struct cmdline_parser_params));
  cmdline_parser_params_init(params);  
  return params;
}

static void
free_string_field (char **s)
{
  if (*s)
    {
      free (*s);
      *s = 0;
    }
}


static void
cmdline_parser_release (struct gengetopt_args_info *args_info)
{

  free_string_field (&(args_info->input_arg));
  free_string_field (&(args_info->input_orig));
  free_string_field (&(args_info->func_name_arg));
  free_string_field (&(args_info->func_name_orig));
  free_string_field (&(args_info->arg_struct_name_arg));
  free_string_field (&(args_info->arg_struct_name_orig));
  free_string_field (&(args_info->file_name_arg));
  free_string_field (&(args_info->file_name_orig));
  free_string_field (&(args_info->output_dir_arg));
  free_string_field (&(args_info->output_dir_orig));
  free_string_field (&(args_info->header_output_dir_arg));
  free_string_field (&(args_info->header_output_dir_orig));
  free_string_field (&(args_info->src_output_dir_arg));
  free_string_field (&(args_info->src_output_dir_orig));
  free_string_field (&(args_info->c_extension_arg));
  free_string_field (&(args_info->c_extension_orig));
  free_string_field (&(args_info->header_extension_arg));
  free_string_field (&(args_info->header_extension_orig));
  free_string_field (&(args_info->unamed_opts_arg));
  free_string_field (&(args_info->unamed_opts_orig));
  free_string_field (&(args_info->show_required_arg));
  free_string_field (&(args_info->show_required_orig));
  free_string_field (&(args_info->set_package_arg));
  free_string_field (&(args_info->set_package_orig));
  free_string_field (&(args_info->set_version_arg));
  free_string_field (&(args_info->set_version_orig));
  
  

  clear_given (args_info);
}


static void
write_into_file(FILE *outfile, const char *opt, const char *arg, const char *values[])
{
  FIX_UNUSED (values);
  if (arg) {
    fprintf(outfile, "%s=\"%s\"\n", opt, arg);
  } else {
    fprintf(outfile, "%s\n", opt);
  }
}


int
cmdline_parser_dump(FILE *outfile, struct gengetopt_args_info *args_info)
{
  int i = 0;

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot dump options to stream\n", CMDLINE_PARSER_PACKAGE);
      return EXIT_FAILURE;
    }

  if (args_info->help_given)
    write_into_file(outfile, "help", 0, 0 );
  if (args_info->detailed_help_given)
    write_into_file(outfile, "detailed-help", 0, 0 );
  if (args_info->version_given)
    write_into_file(outfile, "version", 0, 0 );
  if (args_info->input_given)
    write_into_file(outfile, "input", args_info->input_orig, 0);
  if (args_info->func_name_given)
    write_into_file(outfile, "func-name", args_info->func_name_orig, 0);
  if (args_info->arg_struct_name_given)
    write_into_file(outfile, "arg-struct-name", args_info->arg_struct_name_orig, 0);
  if (args_info->file_name_given)
    write_into_file(outfile, "file-name", args_info->file_name_orig, 0);
  if (args_info->output_dir_given)
    write_into_file(outfile, "output-dir", args_info->output_dir_orig, 0);
  if (args_info->header_output_dir_given)
    write_into_file(outfile, "header-output-dir", args_info->header_output_dir_orig, 0);
  if (args_info->src_output_dir_given)
    write_into_file(outfile, "src-output-dir", args_info->src_output_dir_orig, 0);
  if (args_info->c_extension_given)
    write_into_file(outfile, "c-extension", args_info->c_extension_orig, 0);
  if (args_info->header_extension_given)
    write_into_file(outfile, "header-extension", args_info->header_extension_orig, 0);
  if (args_info->long_help_given)
    write_into_file(outfile, "long-help", 0, 0 );
  if (args_info->default_optional_given)
    write_into_file(outfile, "default-optional", 0, 0 );
  if (args_info->unamed_opts_given)
    write_into_file(outfile, "unamed-opts", args_info->unamed_opts_orig, 0);
  if (args_info->conf_parser_given)
    write_into_file(outfile, "conf-parser", 0, 0 );
  if (args_info->string_parser_given)
    write_into_file(outfile, "string-parser", 0, 0 );
  if (args_info->include_getopt_given)
    write_into_file(outfile, "include-getopt", 0, 0 );
  if (args_info->no_handle_help_given)
    write_into_file(outfile, "no-handle-help", 0, 0 );
  if (args_info->no_help_given)
    write_into_file(outfile, "no-help", 0, 0 );
  if (args_info->no_handle_version_given)
    write_into_file(outfile, "no-handle-version", 0, 0 );
  if (args_info->no_version_given)
    write_into_file(outfile, "no-version", 0, 0 );
  if (args_info->no_handle_error_given)
    write_into_file(outfile, "no-handle-error", 0, 0 );
  if (args_info->show_required_given)
    write_into_file(outfile, "show-required", args_info->show_required_orig, 0);
  if (args_info->gen_version_given)
    write_into_file(outfile, "gen-version", 0, 0 );
  if (args_info->set_package_given)
    write_into_file(outfile, "set-package", args_info->set_package_orig, 0);
  if (args_info->set_version_given)
    write_into_file(outfile, "set-version", args_info->set_version_orig, 0);
  if (args_info->show_help_given)
    write_into_file(outfile, "show-help", 0, 0 );
  if (args_info->show_full_help_given)
    write_into_file(outfile, "show-full-help", 0, 0 );
  if (args_info->show_detailed_help_given)
    write_into_file(outfile, "show-detailed-help", 0, 0 );
  if (args_info->show_version_given)
    write_into_file(outfile, "show-version", 0, 0 );
  

  i = EXIT_SUCCESS;
  return i;
}

int
cmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)
{
  FILE *outfile;
  int i = 0;

  outfile = fopen(filename, "w");

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot open file for writing: %s\n", CMDLINE_PARSER_PACKAGE, filename);
      return EXIT_FAILURE;
    }

  i = cmdline_parser_dump(outfile, args_info);
  fclose (outfile);

  return i;
}

void
cmdline_parser_free (struct gengetopt_args_info *args_info)
{
  cmdline_parser_release (args_info);
}

/** @brief replacement of strdup, which is not standard */
char *
gengetopt_strdup (const char *s)
{
  char *result = 0;
  if (!s)
    return result;

  result = (char*)malloc(strlen(s) + 1);
  if (result == (char*)0)
    return (char*)0;
  strcpy(result, s);
  return result;
}

int
cmdline_parser (int argc, char **argv, struct gengetopt_args_info *args_info)
{
  return cmdline_parser2 (argc, argv, args_info, 0, 1, 1);
}

int
cmdline_parser_ext (int argc, char **argv, struct gengetopt_args_info *args_info,
                   struct cmdline_parser_params *params)
{
  int result;
  result = cmdline_parser_internal (argc, argv, args_info, params, 0);

  return result;
}

int
cmdline_parser2 (int argc, char **argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)
{
  int result;
  struct cmdline_parser_params params;
  
  params.override = override;
  params.initialize = initialize;
  params.check_required = check_required;
  params.check_ambiguity = 0;
  params.print_errors = 1;

  result = cmdline_parser_internal (argc, argv, args_info, &params, 0);

  return result;
}

int
cmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)
{
  FIX_UNUSED (args_info);
  FIX_UNUSED (prog_name);
  return EXIT_SUCCESS;
}


static char *package_name = 0;

/**
 * @brief updates an option
 * @param field the generic pointer to the field to update
 * @param orig_field the pointer to the orig field
 * @param field_given the pointer to the number of occurrence of this option
 * @param prev_given the pointer to the number of occurrence already seen
 * @param value the argument for this option (if null no arg was specified)
 * @param possible_values the possible values for this option (if specified)
 * @param default_value the default value (in case the option only accepts fixed values)
 * @param arg_type the type of this option
 * @param check_ambiguity @see cmdline_parser_params.check_ambiguity
 * @param override @see cmdline_parser_params.override
 * @param no_free whether to free a possible previous value
 * @param multiple_option whether this is a multiple option
 * @param long_opt the corresponding long option
 * @param short_opt the corresponding short option (or '-' if none)
 * @param additional_error possible further error specification
 */
static
int update_arg(void *field, char **orig_field,
               unsigned int *field_given, unsigned int *prev_given, 
               char *value, const char *possible_values[],
               const char *default_value,
               cmdline_parser_arg_type arg_type,
               int check_ambiguity, int override,
               int no_free, int multiple_option,
               const char *long_opt, char short_opt,
               const char *additional_error)
{
  char *stop_char = 0;
  const char *val = value;
  int found;
  char **string_field;
  FIX_UNUSED (field);

  stop_char = 0;
  found = 0;

  if (!multiple_option && prev_given && (*prev_given || (check_ambiguity && *field_given)))
    {
      if (short_opt != '-')
        fprintf (stderr, "%s: `--%s' (`-%c') option given more than once%s\n", 
               package_name, long_opt, short_opt,
               (additional_error ? additional_error : ""));
      else
        fprintf (stderr, "%s: `--%s' option given more than once%s\n", 
               package_name, long_opt,
               (additional_error ? additional_error : ""));
      return 1; /* failure */
    }

  FIX_UNUSED (default_value);
    
  if (field_given && *field_given && ! override)
    return 0;
  if (prev_given)
    (*prev_given)++;
  if (field_given)
    (*field_given)++;
  if (possible_values)
    val = possible_values[found];

  switch(arg_type) {
  case ARG_FLAG:
    *((int *)field) = !*((int *)field);
    break;
  case ARG_STRING:
    if (val) {
      string_field = (char **)field;
      if (!no_free && *string_field)
        free (*string_field); /* free previous string */
      *string_field = gengetopt_strdup (val);
    }
    break;
  default:
    break;
  };


  /* store the original value */
  switch(arg_type) {
  case ARG_NO:
  case ARG_FLAG:
    break;
  default:
    if (value && orig_field) {
      if (no_free) {
        *orig_field = value;
      } else {
        if (*orig_field)
          free (*orig_field); /* free previous string */
        *orig_field = gengetopt_strdup (value);
      }
    }
  };

  return 0; /* OK */
}


int
cmdline_parser_internal (
  int argc, char **argv, struct gengetopt_args_info *args_info,
                        struct cmdline_parser_params *params, const char *additional_error)
{
  int c;	/* Character of the parsed option.  */

  int error = 0;
  struct gengetopt_args_info local_args_info;
  
  int override;
  int initialize;
  int check_required;
  int check_ambiguity;
  
  package_name = argv[0];
  
  override = params->override;
  initialize = params->initialize;
  check_required = params->check_required;
  check_ambiguity = params->check_ambiguity;

  if (initialize)
    cmdline_parser_init (args_info);

  cmdline_parser_init (&local_args_info);

  optarg = 0;
  optind = 0;
  opterr = params->print_errors;
  optopt = '?';

  while (1)
    {
      int option_index = 0;

      static struct option long_options[] = {
        { "help",	0, NULL, 'h' },
        { "detailed-help",	0, NULL, 0 },
        { "version",	0, NULL, 'V' },
        { "input",	1, NULL, 'i' },
        { "func-name",	1, NULL, 'f' },
        { "arg-struct-name",	1, NULL, 'a' },
        { "file-name",	1, NULL, 'F' },
        { "output-dir",	1, NULL, 0 },
        { "header-output-dir",	1, NULL, 0 },
        { "src-output-dir",	1, NULL, 0 },
        { "c-extension",	1, NULL, 'c' },
        { "header-extension",	1, NULL, 'H' },
        { "long-help",	0, NULL, 'l' },
        { "default-optional",	0, NULL, 0 },
        { "unamed-opts",	2, NULL, 'u' },
        { "conf-parser",	0, NULL, 'C' },
        { "string-parser",	0, NULL, 'S' },
        { "include-getopt",	0, NULL, 'G' },
        { "no-handle-help",	0, NULL, 'n' },
        { "no-help",	0, NULL, 0 },
        { "no-handle-version",	0, NULL, 'N' },
        { "no-version",	0, NULL, 0 },
        { "no-handle-error",	0, NULL, 'e' },
        { "show-required",	2, NULL, 0 },
        { "gen-version",	0, NULL, 'g' },
        { "set-package",	1, NULL, 0 },
        { "set-version",	1, NULL, 0 },
        { "show-help",	0, NULL, 0 },
        { "show-full-help",	0, NULL, 0 },
        { "show-detailed-help",	0, NULL, 0 },
        { "show-version",	0, NULL, 0 },
        { 0,  0, 0, 0 }
      };

      c = getopt_long (argc, argv, "hVi:f:a:F:c:H:lu::CSGnNeg", long_options, &option_index);

      if (c == -1) break;	/* Exit from `while (1)' loop.  */

      switch (c)
        {
        case 'h':	/* Print help and exit.  */
        
        
          if (update_arg( 0 , 
               0 , &(args_info->help_given),
              &(local_args_info.help_given), optarg, 0, 0, ARG_NO,
              check_ambiguity, override, 0, 0,
              "help", 'h',
              additional_error))
            goto failure;
          cmdline_parser_free (&local_args_info);
          return 0;
        
          break;
        case 'V':	/* Print version and exit.  */
        
        
          if (update_arg( 0 , 
               0 , &(args_info->version_given),
              &(local_args_info.version_given), optarg, 0, 0, ARG_NO,
              check_ambiguity, override, 0, 0,
              "version", 'V',
              additional_error))
            goto failure;
          cmdline_parser_free (&local_args_info);
          return 0;
        
          break;
        case 'i':	/* input file (default std input).  */
        
        
          if (update_arg( (void *)&(args_info->input_arg), 
               &(args_info->input_orig), &(args_info->input_given),
              &(local_args_info.input_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "input", 'i',
              additional_error))
            goto failure;
        
          break;
        case 'f':	/* name of generated function.  */
        
        
          if (update_arg( (void *)&(args_info->func_name_arg), 
               &(args_info->func_name_orig), &(args_info->func_name_given),
              &(local_args_info.func_name_given), optarg, 0, "cmdline_parser", ARG_STRING,
              check_ambiguity, override, 0, 0,
              "func-name", 'f',
              additional_error))
            goto failure;
        
          break;
        case 'a':	/* name of generated args info struct.  */
        
        
          if (update_arg( (void *)&(args_info->arg_struct_name_arg), 
               &(args_info->arg_struct_name_orig), &(args_info->arg_struct_name_given),
              &(local_args_info.arg_struct_name_given), optarg, 0, "gengetopt_args_info", ARG_STRING,
              check_ambiguity, override, 0, 0,
              "arg-struct-name", 'a',
              additional_error))
            goto failure;
        
          break;
        case 'F':	/* name of generated file.  */
        
        
          if (update_arg( (void *)&(args_info->file_name_arg), 
               &(args_info->file_name_orig), &(args_info->file_name_given),
              &(local_args_info.file_name_given), optarg, 0, "cmdline", ARG_STRING,
              check_ambiguity, override, 0, 0,
              "file-name", 'F',
              additional_error))
            goto failure;
        
          break;
        case 'c':	/* extension of c file.  */
        
        
          if (update_arg( (void *)&(args_info->c_extension_arg), 
               &(args_info->c_extension_orig), &(args_info->c_extension_given),
              &(local_args_info.c_extension_given), optarg, 0, "c", ARG_STRING,
              check_ambiguity, override, 0, 0,
              "c-extension", 'c',
              additional_error))
            goto failure;
        
          break;
        case 'H':	/* extension of header file.  */
        
        
          if (update_arg( (void *)&(args_info->header_extension_arg), 
               &(args_info->header_extension_orig), &(args_info->header_extension_given),
              &(local_args_info.header_extension_given), optarg, 0, "h", ARG_STRING,
              check_ambiguity, override, 0, 0,
              "header-extension", 'H',
              additional_error))
            goto failure;
        
          break;
        case 'l':	/* long usage line in help.  */
        
        
          if (update_arg( 0 , 
               0 , &(args_info->long_help_given),
              &(local_args_info.long_help_given), optarg, 0, 0, ARG_NO,
              check_ambiguity, override, 0, 0,
              "long-help", 'l',
              additional_error))
            goto failure;
        
          break;
        case 'u':	/* accept options without names (e.g., file names).  */
        
        
          if (update_arg( (void *)&(args_info->unamed_opts_arg), 
               &(args_info->unamed_opts_orig), &(args_info->unamed_opts_given),
              &(local_args_info.unamed_opts_given), optarg, 0, "FILES", ARG_STRING,
              check_ambiguity, override, 0, 0,
              "unamed-opts", 'u',
              additional_error))
            goto failure;
        
          break;
        case 'C':	/* generate a config file parser.  */
        
        
          if (update_arg( 0 , 
               0 , &(args_info->conf_parser_given),
              &(local_args_info.conf_parser_given), optarg, 0, 0, ARG_NO,
              check_ambiguity, override, 0, 0,
              "conf-parser", 'C',
              additional_error))
            goto failure;
        
          break;
        case 'S':	/* generate a string parser (the string contains the command line).  */
        
        
          if (update_arg( 0 , 
               0 , &(args_info->string_parser_given),
              &(local_args_info.string_parser_given), optarg, 0, 0, ARG_NO,
              check_ambiguity, override, 0, 0,
              "string-parser", 'S',
              additional_error))
            goto failure;
        
          break;
        case 'G':	/* adds the code for getopt_long in the generated C file.  */
        
        
          if (update_arg( 0 , 
               0 , &(args_info->include_getopt_given),
              &(local_args_info.include_getopt_given), optarg, 0, 0, ARG_NO,
              check_ambiguity, override, 0, 0,
              "include-getopt", 'G',
              additional_error))
            goto failure;
        
          break;
        case 'n':	/* do not handle --help|-h automatically.  */
        
        
          if (update_arg( 0 , 
               0 , &(args_info->no_handle_help_given),
              &(local_args_info.no_handle_help_given), optarg, 0, 0, ARG_NO,
              check_ambiguity, override, 0, 0,
              "no-handle-help", 'n',
              additional_error))
            goto failure;
        
          break;
        case 'N':	/* do not handle --version|-V automatically.  */
        
        
          if (update_arg( 0 , 
               0 , &(args_info->no_handle_version_given),
              &(local_args_info.no_handle_version_given), optarg, 0, 0, ARG_NO,
              check_ambiguity, override, 0, 0,
              "no-handle-version", 'N',
              additional_error))
            goto failure;
        
          break;
        case 'e':	/* do not exit on errors.  */
        
        
          if (update_arg( 0 , 
               0 , &(args_info->no_handle_error_given),
              &(local_args_info.no_handle_error_given), optarg, 0, 0, ARG_NO,
              check_ambiguity, override, 0, 0,
              "no-handle-error", 'e',
              additional_error))
            goto failure;
        
          break;
        case 'g':	/* put gengetopt version in the generated file.  */
        
        
          if (update_arg((void *)&(args_info->gen_version_flag), 0, &(args_info->gen_version_given),
              &(local_args_info.gen_version_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "gen-version", 'g',
              additional_error))
            goto failure;
        
          break;

        case 0:	/* Long option with no short option */
          /* Print help, including all details and hidden options, and exit.  */
          if (strcmp (long_options[option_index].name, "detailed-help") == 0)
          {
          
          
            if (update_arg( 0 , 
                 0 , &(args_info->detailed_help_given),
                &(local_args_info.detailed_help_given), optarg, 0, 0, ARG_NO,
                check_ambiguity, override, 0, 0,
                "detailed-help", '-',
                additional_error))
              goto failure;
            cmdline_parser_free (&local_args_info);
            return 0;
          
          }
          /* output directory.  */
          else if (strcmp (long_options[option_index].name, "output-dir") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->output_dir_arg), 
                 &(args_info->output_dir_orig), &(args_info->output_dir_given),
                &(local_args_info.output_dir_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "output-dir", '-',
                additional_error))
              goto failure;
          
          }
          /* header output directory.  */
          else if (strcmp (long_options[option_index].name, "header-output-dir") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->header_output_dir_arg), 
                 &(args_info->header_output_dir_orig), &(args_info->header_output_dir_given),
                &(local_args_info.header_output_dir_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "header-output-dir", '-',
                additional_error))
              goto failure;
          
          }
          /* source output directory.  */
          else if (strcmp (long_options[option_index].name, "src-output-dir") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->src_output_dir_arg), 
                 &(args_info->src_output_dir_orig), &(args_info->src_output_dir_given),
                &(local_args_info.src_output_dir_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "src-output-dir", '-',
                additional_error))
              goto failure;
          
          }
          /* by default, an option is considered optional if not specified otherwise.  */
          else if (strcmp (long_options[option_index].name, "default-optional") == 0)
          {
          
          
            if (update_arg( 0 , 
                 0 , &(args_info->default_optional_given),
                &(local_args_info.default_optional_given), optarg, 0, 0, ARG_NO,
                check_ambiguity, override, 0, 0,
                "default-optional", '-',
                additional_error))
              goto failure;
          
          }
          /* do not add --help|-h automatically.  */
          else if (strcmp (long_options[option_index].name, "no-help") == 0)
          {
          
          
            if (update_arg( 0 , 
                 0 , &(args_info->no_help_given),
                &(local_args_info.no_help_given), optarg, 0, 0, ARG_NO,
                check_ambiguity, override, 0, 0,
                "no-help", '-',
                additional_error))
              goto failure;
          
          }
          /* do not add --version|-V automatically.  */
          else if (strcmp (long_options[option_index].name, "no-version") == 0)
          {
          
          
            if (update_arg( 0 , 
                 0 , &(args_info->no_version_given),
                &(local_args_info.no_version_given), optarg, 0, 0, ARG_NO,
                check_ambiguity, override, 0, 0,
                "no-version", '-',
                additional_error))
              goto failure;
          
          }
          /* in the output of help will specify which options are mandatory, by using the optional passed string.  */
          else if (strcmp (long_options[option_index].name, "show-required") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->show_required_arg), 
                 &(args_info->show_required_orig), &(args_info->show_required_given),
                &(local_args_info.show_required_given), optarg, 0, "(mandatory)", ARG_STRING,
                check_ambiguity, override, 0, 0,
                "show-required", '-',
                additional_error))
              goto failure;
          
          }
          /* set the package name (override package defined in the .ggo file).  */
          else if (strcmp (long_options[option_index].name, "set-package") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->set_package_arg), 
                 &(args_info->set_package_orig), &(args_info->set_package_given),
                &(local_args_info.set_package_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "set-package", '-',
                additional_error))
              goto failure;
          
          }
          /* set the version number (override version defined in the .ggo file).  */
          else if (strcmp (long_options[option_index].name, "set-version") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->set_version_arg), 
                 &(args_info->set_version_orig), &(args_info->set_version_given),
                &(local_args_info.set_version_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "set-version", '-',
                additional_error))
              goto failure;
          
          }
          /* show the output of --help instead of generating code.  */
          else if (strcmp (long_options[option_index].name, "show-help") == 0)
          {
          
          
            if (update_arg( 0 , 
                 0 , &(args_info->show_help_given),
                &(local_args_info.show_help_given), optarg, 0, 0, ARG_NO,
                check_ambiguity, override, 0, 0,
                "show-help", '-',
                additional_error))
              goto failure;
          
          }
          /* show the output of --full-help (i.e., including hidden options) instead of generating code.  */
          else if (strcmp (long_options[option_index].name, "show-full-help") == 0)
          {
          
          
            if (update_arg( 0 , 
                 0 , &(args_info->show_full_help_given),
                &(local_args_info.show_full_help_given), optarg, 0, 0, ARG_NO,
                check_ambiguity, override, 0, 0,
                "show-full-help", '-',
                additional_error))
              goto failure;
          
          }
          /* show the output of --detailed-help (i.e., including details and hidden options) instead of generating code.  */
          else if (strcmp (long_options[option_index].name, "show-detailed-help") == 0)
          {
          
          
            if (update_arg( 0 , 
                 0 , &(args_info->show_detailed_help_given),
                &(local_args_info.show_detailed_help_given), optarg, 0, 0, ARG_NO,
                check_ambiguity, override, 0, 0,
                "show-detailed-help", '-',
                additional_error))
              goto failure;
          
          }
          /* show the output of --version instead of generating code.  */
          else if (strcmp (long_options[option_index].name, "show-version") == 0)
          {
          
          
            if (update_arg( 0 , 
                 0 , &(args_info->show_version_given),
                &(local_args_info.show_version_given), optarg, 0, 0, ARG_NO,
                check_ambiguity, override, 0, 0,
                "show-version", '-',
                additional_error))
              goto failure;
          
          }
          
          break;
        case '?':	/* Invalid option.  */
          /* `getopt_long' already printed an error message.  */
          goto failure;

        default:	/* bug: option not considered.  */
          fprintf (stderr, "%s: option unknown: %c%s\n", CMDLINE_PARSER_PACKAGE, c, (additional_error ? additional_error : ""));
          abort ();
        } /* switch */
    } /* while */




  cmdline_parser_release (&local_args_info);

  if ( error )
    return (EXIT_FAILURE);

  return 0;

failure:
  
  cmdline_parser_release (&local_args_info);
  return (EXIT_FAILURE);
}

static unsigned int
cmdline_parser_create_argv(const char *cmdline_, char ***argv_ptr, const char *prog_name)
{
  char *cmdline, *p;
  size_t n = 0, j;
  int i;

  if (prog_name) {
    cmd_line_list_tmp = (struct line_list *) malloc (sizeof (struct line_list));
    cmd_line_list_tmp->next = cmd_line_list;
    cmd_line_list = cmd_line_list_tmp;
    cmd_line_list->string_arg = gengetopt_strdup (prog_name);

    ++n;
  }

  cmdline = gengetopt_strdup(cmdline_);
  p = cmdline;

  while (p && strlen(p))
    {
      j = strcspn(p, " \t");
      ++n;
      if (j && j < strlen(p))
        {
          p[j] = '\0';

          cmd_line_list_tmp = (struct line_list *) malloc (sizeof (struct line_list));
          cmd_line_list_tmp->next = cmd_line_list;
          cmd_line_list = cmd_line_list_tmp;
          cmd_line_list->string_arg = gengetopt_strdup (p);

          p += (j+1);
          p += strspn(p, " \t");
        }
      else
        {
          cmd_line_list_tmp = (struct line_list *) malloc (sizeof (struct line_list));
          cmd_line_list_tmp->next = cmd_line_list;
          cmd_line_list = cmd_line_list_tmp;
          cmd_line_list->string_arg = gengetopt_strdup (p);

          break;
        }
    }

  *argv_ptr = (char **) malloc((n + 1) * sizeof(char *));
  cmd_line_list_tmp = cmd_line_list;
  for (i = (n-1); i >= 0; --i)
    {
      (*argv_ptr)[i] = cmd_line_list_tmp->string_arg;
      cmd_line_list_tmp = cmd_line_list_tmp->next;
    }

  (*argv_ptr)[n] = 0;

  free(cmdline);
  return n;
}

int
cmdline_parser_string(const char *cmdline, struct gengetopt_args_info *args_info, const char *prog_name)
{
  return cmdline_parser_string2(cmdline, args_info, prog_name, 0, 1, 1);
}

int
cmdline_parser_string2(const char *cmdline, struct gengetopt_args_info *args_info, const char *prog_name,
    int override, int initialize, int check_required)
{
  struct cmdline_parser_params params;

  params.override = override;
  params.initialize = initialize;
  params.check_required = check_required;
  params.check_ambiguity = 0;
  params.print_errors = 1;

  return cmdline_parser_string_ext(cmdline, args_info, prog_name, &params);
}

int
cmdline_parser_string_ext(const char *cmdline, struct gengetopt_args_info *args_info, const char *prog_name,
    struct cmdline_parser_params *params)
{
  char **argv_ptr = 0;
  int result;
  unsigned int argc;
  
  argc = cmdline_parser_create_argv(cmdline, &argv_ptr, prog_name);
  
  result =
    cmdline_parser_internal (argc, argv_ptr, args_info, params, 0);
  
  if (argv_ptr)
    {
      free (argv_ptr);
    }

  free_cmd_list();
  
  return result;
}

